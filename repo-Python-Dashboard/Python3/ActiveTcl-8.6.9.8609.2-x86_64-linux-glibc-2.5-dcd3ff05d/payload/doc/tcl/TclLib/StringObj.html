<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="en-us">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=10" />
    <title>ActiveTcl 8.6.9 Documentation</title>
    <meta name="generator" content="Hugo 0.26" />

    
    <meta name="description" content="Complete documentation for ActiveTcl 8.6.9">
    
    <link rel="canonical" href="StringObj.html">
    

    
    <meta name="apple-mobile-web-app-title" content="ActiveTcl 8.6.9 Documentation">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="../../images/favicon.ico">
    <link rel="icon" type="image/x-icon" href="../../images/favicon.ico">

    <style>
      @font-face {
        font-family: 'Icon';
        src: url('../../fonts/icon.eot');
        src: url('../../fonts/icon.eot')
               format('embedded-opentype'),
             url('../../fonts/icon.woff')
               format('woff'),
             url('../../fonts/icon.ttf')
               format('truetype'),
             url('../../fonts/icon.svg')
               format('svg');
        font-weight: normal;
        font-style: normal;
      }
    </style>

    <link rel="stylesheet" href="../../stylesheets/application.css">
    <link rel="stylesheet" href="../../stylesheets/temporary.css">
    <link rel="stylesheet" href="../../stylesheets/palettes.css">
    <link rel="stylesheet" href="../../stylesheets/highlight/highlight.css">

    
    
    
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open%20Sans:400,700|Source+Code+Pro">
    <style>
      body, input {
        font-family: 'Open Sans', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Source Code Pro', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <link rel="stylesheet" href="../../stylesheets/as_common.css">
    
    <link rel="stylesheet" href="../../stylesheets/as_custom.css">
    
    <script src="../../javascripts/modernizr.js"></script>

    

  </head>
  <body class="palette-primary-grey palette-accent-red">




<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="logo">
        <a href="http://www.activestate.com/">
          <img src="../../images/logo.png" alt="ActiveState homepage">
        </a>
      </div>
      <div class="title">
        <a href="http://docs.activestate.com/">docs.activestate.com</a>
      </div>
    </div>

    

    
    
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>

</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="../../index.html" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="../../images/as_tcl.png">
        </div>
      
      <div class="name">
        <strong>ActiveTcl 8.6.9 Documentation </strong>
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      

      <div class="toc">
        
        <ul>
          




<li>
  



<a  title="Get ActiveTcl" href="../../get/index.html">
	
	Get ActiveTcl
</a>



  
    <ul>
      
        
        



<a  title="Release notes" href="../../get/relnotes/index.html">
	
	Release notes
</a>



      
        
        



<a  title="Windows installation" href="../../get/windows/index.html">
	
	Windows installation
</a>



      
        
        



<a  title="Linux/Unix Installaton" href="../../get/linux/index.html">
	
	Linux/Unix Installaton
</a>



      
        
        



<a  title="macOS Installation" href="../../get/macos/index.html">
	
	macOS Installation
</a>



      
        
        



<a  title="License" href="../../get/license/index.html">
	
	License
</a>



      
    </ul>
  
</li>



<li>
  



<a  title="Get Started" href="../../start/index.html">
	
	Get Started
</a>



  
    <ul>
      
        
        



<a  title="Package Reference" href="../../pkg/index.html">
	
	Package Reference
</a>



      
        
        



<a  title="Tcl 8.6.9 docs" href="../contents.html">
	
	Tcl 8.6.9 docs
</a>



      
    </ul>
  
</li>



<li>
  



<a  title="Contact Us" href="../../contact/index.html">
	
	Contact Us
</a>



  
</li>


        </ul>
        

        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1> </h1>

			<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD><TITLE>Tcl_StringObj manual page - Tcl Library Procedures</TITLE>
<link rel="stylesheet" href="../docs.css" type="text/css" media="all">
</HEAD>
<BODY><H2><a href="../contents.html">Tcl8.6.9/Tk8.6.9 Documentation</a> <small>&gt;</small> <a href="contents.html">Tcl C API, version 8.6.9</a> <small>&gt;</small> StringObj</H2>
<H3><A HREF="../UserCmd/contents.html">Tcl/Tk Applications</A> | <A HREF="../TclCmd/contents.html">Tcl Commands</A> | <A HREF="../TkCmd/contents.html">Tk Commands</A> | <A HREF="../ItclCmd/contents.html">[incr Tcl] Package Commands</A> | <A HREF="../SqliteCmd/contents.html">SQLite3 Package Commands</A> | <A HREF="../TdbcCmd/contents.html">TDBC Package Commands</A> | <A HREF="../TdbcmysqlCmd/contents.html">tdbc::mysql Package Commands</A> | <A HREF="../TdbcodbcCmd/contents.html">tdbc::odbc Package Commands</A> | <A HREF="../TdbcpostgresCmd/contents.html">tdbc::postgres Package Commands</A> | <A HREF="../TdbcsqliteCmd/contents.html">tdbc::sqlite3 Package Commands</A> | <A HREF="../ThreadCmd/contents.html">Thread Package Commands</A> | <A HREF="contents.html">Tcl C API</A> | <A HREF="../TkLib/contents.html">Tk C API</A> | <A HREF="../ItclLib/contents.html">[incr Tcl] Package C API</A> | <A HREF="../TdbcLib/contents.html">TDBC Package C API</A></H3>
<DL>
<DD><A HREF="StringObj.html#M2" NAME="L775">NAME</A>
<DL><DD>Tcl_NewStringObj, Tcl_NewUnicodeObj, Tcl_SetStringObj, Tcl_SetUnicodeObj, Tcl_GetStringFromObj, Tcl_GetString, Tcl_GetUnicodeFromObj, Tcl_GetUnicode, Tcl_GetUniChar, Tcl_GetCharLength, Tcl_GetRange, Tcl_AppendToObj, Tcl_AppendUnicodeToObj, Tcl_AppendObjToObj, Tcl_AppendStringsToObj, Tcl_AppendStringsToObjVA, Tcl_AppendLimitedToObj, Tcl_Format, Tcl_AppendFormatToObj, Tcl_ObjPrintf, Tcl_AppendPrintfToObj, Tcl_SetObjLength, Tcl_AttemptSetObjLength, Tcl_ConcatObj &mdash; manipulate Tcl values as strings</DD></DL>
<DD><A HREF="StringObj.html#M3" NAME="L776">SYNOPSIS</A>
<DL>
<DD><B>#include &lt;tcl.h&gt;</B>
<DD>Tcl_Obj *
<DD><B>Tcl_NewStringObj</B>(<I>bytes, length</I>)
<DD>Tcl_Obj *
<DD><B>Tcl_NewUnicodeObj</B>(<I>unicode, numChars</I>)
<DD>void
<DD><B>Tcl_SetStringObj</B>(<I>objPtr, bytes, length</I>)
<DD>void
<DD><B>Tcl_SetUnicodeObj</B>(<I>objPtr, unicode, numChars</I>)
<DD>char *
<DD><B>Tcl_GetStringFromObj</B>(<I>objPtr, lengthPtr</I>)
<DD>char *
<DD><B>Tcl_GetString</B>(<I>objPtr</I>)
<DD>Tcl_UniChar *
<DD><B>Tcl_GetUnicodeFromObj</B>(<I>objPtr, lengthPtr</I>)
<DD>Tcl_UniChar *
<DD><B>Tcl_GetUnicode</B>(<I>objPtr</I>)
<DD>Tcl_UniChar
<DD><B>Tcl_GetUniChar</B>(<I>objPtr, index</I>)
<DD>int
<DD><B>Tcl_GetCharLength</B>(<I>objPtr</I>)
<DD>Tcl_Obj *
<DD><B>Tcl_GetRange</B>(<I>objPtr, first, last</I>)
<DD>void
<DD><B>Tcl_AppendToObj</B>(<I>objPtr, bytes, length</I>)
<DD>void
<DD><B>Tcl_AppendUnicodeToObj</B>(<I>objPtr, unicode, numChars</I>)
<DD>void
<DD><B>Tcl_AppendObjToObj</B>(<I>objPtr, appendObjPtr</I>)
<DD>void
<DD><B>Tcl_AppendStringsToObj</B>(<I>objPtr, string, string, ... </I><B>(char *) NULL</B>)
<DD>void
<DD><B>Tcl_AppendStringsToObjVA</B>(<I>objPtr, argList</I>)
<DD>void
<DD><B>Tcl_AppendLimitedToObj</B>(<I>objPtr, bytes, length, limit, ellipsis</I>)
<DD>Tcl_Obj *
<DD><B>Tcl_Format</B>(<I>interp, format, objc, objv</I>)
<DD>int
<DD><B>Tcl_AppendFormatToObj</B>(<I>interp, objPtr, format, objc, objv</I>)
<DD>Tcl_Obj *
<DD><B>Tcl_ObjPrintf</B>(<I>format, ...</I>)
<DD>void
<DD><B>Tcl_AppendPrintfToObj</B>(<I>objPtr, format, ...</I>)
<DD>void
<DD><B>Tcl_SetObjLength</B>(<I>objPtr, newLength</I>)
<DD>int
<DD><B>Tcl_AttemptSetObjLength</B>(<I>objPtr, newLength</I>)
<DD>Tcl_Obj *
<DD><B>Tcl_ConcatObj</B>(<I>objc, objv</I>)
</DL>
<DD><A HREF="StringObj.html#M4" NAME="L777">ARGUMENTS</A>
<DL class="arguments">
</DL>
<DD><A HREF="StringObj.html#M5" NAME="L778">DESCRIPTION</A>
<DD><A HREF="StringObj.html#M6" NAME="L779">SEE ALSO</A>
<DD><A HREF="StringObj.html#M7" NAME="L780">KEYWORDS</A>
</DL>
<H3><A NAME="M2">NAME</A></H3>
Tcl_NewStringObj, Tcl_NewUnicodeObj, Tcl_SetStringObj, Tcl_SetUnicodeObj, Tcl_GetStringFromObj, Tcl_GetString, Tcl_GetUnicodeFromObj, Tcl_GetUnicode, Tcl_GetUniChar, Tcl_GetCharLength, Tcl_GetRange, Tcl_AppendToObj, Tcl_AppendUnicodeToObj, Tcl_AppendObjToObj, Tcl_AppendStringsToObj, Tcl_AppendStringsToObjVA, Tcl_AppendLimitedToObj, Tcl_Format, Tcl_AppendFormatToObj, Tcl_ObjPrintf, Tcl_AppendPrintfToObj, Tcl_SetObjLength, Tcl_AttemptSetObjLength, Tcl_ConcatObj &mdash; manipulate Tcl values as strings
<H3><A NAME="M3">SYNOPSIS</A></H3>
<B>#include &lt;tcl.h&gt;</B><BR>
<A HREF="Object.html">Tcl_Obj</A> *<BR>
<B>Tcl_NewStringObj</B>(<I>bytes, length</I>)<BR>
<A HREF="Object.html">Tcl_Obj</A> *<BR>
<B>Tcl_NewUnicodeObj</B>(<I>unicode, numChars</I>)<BR>
void<BR>
<B>Tcl_SetStringObj</B>(<I>objPtr, bytes, length</I>)<BR>
void<BR>
<B>Tcl_SetUnicodeObj</B>(<I>objPtr, unicode, numChars</I>)<BR>
char *<BR>
<B>Tcl_GetStringFromObj</B>(<I>objPtr, lengthPtr</I>)<BR>
char *<BR>
<B>Tcl_GetString</B>(<I>objPtr</I>)<BR>
<A HREF="Utf.html">Tcl_UniChar</A> *<BR>
<B>Tcl_GetUnicodeFromObj</B>(<I>objPtr, lengthPtr</I>)<BR>
<A HREF="Utf.html">Tcl_UniChar</A> *<BR>
<B>Tcl_GetUnicode</B>(<I>objPtr</I>)<BR>
<A HREF="Utf.html">Tcl_UniChar</A><BR>
<B>Tcl_GetUniChar</B>(<I>objPtr, index</I>)<BR>
int<BR>
<B>Tcl_GetCharLength</B>(<I>objPtr</I>)<BR>
<A HREF="Object.html">Tcl_Obj</A> *<BR>
<B>Tcl_GetRange</B>(<I>objPtr, first, last</I>)<BR>
void<BR>
<B>Tcl_AppendToObj</B>(<I>objPtr, bytes, length</I>)<BR>
void<BR>
<B>Tcl_AppendUnicodeToObj</B>(<I>objPtr, unicode, numChars</I>)<BR>
void<BR>
<B>Tcl_AppendObjToObj</B>(<I>objPtr, appendObjPtr</I>)<BR>
void<BR>
<B>Tcl_AppendStringsToObj</B>(<I>objPtr, string, string, ... </I><B>(char *) NULL</B>)<BR>
void<BR>
<B>Tcl_AppendStringsToObjVA</B>(<I>objPtr, argList</I>)<BR>
void<BR>
<B>Tcl_AppendLimitedToObj</B>(<I>objPtr, bytes, length, limit, ellipsis</I>)<BR>
<A HREF="Object.html">Tcl_Obj</A> *<BR>
<B>Tcl_Format</B>(<I>interp, format, objc, objv</I>)<BR>
int<BR>
<B>Tcl_AppendFormatToObj</B>(<I>interp, objPtr, format, objc, objv</I>)<BR>
<A HREF="Object.html">Tcl_Obj</A> *<BR>
<B>Tcl_ObjPrintf</B>(<I>format, ...</I>)<BR>
void<BR>
<B>Tcl_AppendPrintfToObj</B>(<I>objPtr, format, ...</I>)<BR>
void<BR>
<B>Tcl_SetObjLength</B>(<I>objPtr, newLength</I>)<BR>
int<BR>
<B>Tcl_AttemptSetObjLength</B>(<I>objPtr, newLength</I>)<BR>
<A HREF="Object.html">Tcl_Obj</A> *<BR>
<B>Tcl_ConcatObj</B>(<I>objc, objv</I>)<BR>
<H3><A NAME="M4">ARGUMENTS</A></H3>
<DL class="arguments">
<DT>const char <B>*bytes</B> (in)<DD>
Points to the first byte of an array of UTF-8-encoded bytes
used to set or append to a string value.
This byte array may contain embedded null characters
unless <I>numChars</I> is negative.  (Applications needing null bytes
should represent them as the two-byte sequence <I>&#92;700&#92;600</I>, use
<B><A HREF="Encoding.html">Tcl_ExternalToUtf</A></B> to convert, or <B><A HREF="ByteArrObj.html">Tcl_NewByteArrayObj</A></B> if
the string is a collection of uninterpreted bytes.)
<P><DT>int <B>length</B> (in)<DD>
The number of bytes to copy from <I>bytes</I> when
initializing, setting, or appending to a string value.
If negative, all bytes up to the first null are used.
<P><DT>const <A HREF="Utf.html">Tcl_UniChar</A> <B>*unicode</B> (in)<DD>
Points to the first byte of an array of Unicode characters
used to set or append to a string value.
This byte array may contain embedded null characters
unless <I>numChars</I> is negative.
<P><DT>int <B>numChars</B> (in)<DD>
The number of Unicode characters to copy from <I>unicode</I> when
initializing, setting, or appending to a string value.
If negative, all characters up to the first null character are used.
<P><DT>int <B>index</B> (in)<DD>
The index of the Unicode character to return.
<P><DT>int <B>first</B> (in)<DD>
The index of the first Unicode character in the Unicode range to be
returned as a new value.
<P><DT>int <B>last</B> (in)<DD>
The index of the last Unicode character in the Unicode range to be
returned as a new value.
<P><DT><A HREF="Object.html">Tcl_Obj</A> <B>*objPtr</B> (in/out)<DD>
Points to a value to manipulate.
<P><DT><A HREF="Object.html">Tcl_Obj</A> <B>*appendObjPtr</B> (in)<DD>
The value to append to <I>objPtr</I> in <B>Tcl_AppendObjToObj</B>.
<P><DT>int <B>*lengthPtr</B> (out)<DD>
If non-NULL, the location where <B>Tcl_GetStringFromObj</B> will store
the length of a value's string representation.
<P><DT>const char <B>*string</B> (in)<DD>
Null-terminated string value to append to <I>objPtr</I>.
<P><DT>va_list <B>argList</B> (in)<DD>
An argument list which must have been initialized using
<B>va_start</B>, and cleared using <B>va_end</B>.
<P><DT>int <B>limit</B> (in)<DD>
Maximum number of bytes to be appended.
<P><DT>const char <B>*ellipsis</B> (in)<DD>
Suffix to append when the limit leads to string truncation.
If NULL is passed then the suffix
&#8220;...&#8221;
is used.
<P><DT>const char <B>*format</B> (in)<DD>
Format control string including % conversion specifiers.
<P><DT>int <B>objc</B> (in)<DD>
The number of elements to format or concatenate.
<P><DT><A HREF="Object.html">Tcl_Obj</A> <B>*objv[]</B> (in)<DD>
The array of values to format or concatenate.
<P><DT>int <B>newLength</B> (in)<DD>
New length for the string value of <I>objPtr</I>, not including the
final null character.
<P></DL>
<H3><A NAME="M5">DESCRIPTION</A></H3>
The procedures described in this manual entry allow Tcl values to
be manipulated as string values.  They use the internal representation
of the value to store additional information to make the string
manipulations more efficient.  In particular, they make a series of
append operations efficient by allocating extra storage space for the
string so that it does not have to be copied for each append.
Also, indexing and length computations are optimized because the
Unicode string representation is calculated and cached as needed.
When using the <B>Tcl_Append*</B> family of functions where the
interpreter's result is the value being appended to, it is important
to call <A HREF="SetResult.html">Tcl_ResetResult</A> first to ensure you are not unintentionally
appending to existing data in the result value.
<P>
<B>Tcl_NewStringObj</B> and <B>Tcl_SetStringObj</B> create a new value
or modify an existing value to hold a copy of the string given by
<I>bytes</I> and <I>length</I>.  <B>Tcl_NewUnicodeObj</B> and
<B>Tcl_SetUnicodeObj</B> create a new value or modify an existing
value to hold a copy of the Unicode string given by <I>unicode</I> and
<I>numChars</I>.  <B>Tcl_NewStringObj</B> and <B>Tcl_NewUnicodeObj</B>
return a pointer to a newly created value with reference count zero.
All four procedures set the value to hold a copy of the specified
string.  <B>Tcl_SetStringObj</B> and <B>Tcl_SetUnicodeObj</B> free any
old string representation as well as any old internal representation
of the value.
<P>
<B>Tcl_GetStringFromObj</B> and <B>Tcl_GetString</B> return a value's
string representation.  This is given by the returned byte pointer and
(for <B>Tcl_GetStringFromObj</B>) length, which is stored in
<I>lengthPtr</I> if it is non-NULL.  If the value's UTF string
representation is invalid (its byte pointer is NULL), the string
representation is regenerated from the value's internal
representation.  The storage referenced by the returned byte pointer
is owned by the value manager.  It is passed back as a writable
pointer so that extension author creating their own <B><A HREF="ObjectType.html">Tcl_ObjType</A></B>
will be able to modify the string representation within the
<B>Tcl_UpdateStringProc</B> of their <B><A HREF="ObjectType.html">Tcl_ObjType</A></B>.  Except for that
limited purpose, the pointer returned by <B>Tcl_GetStringFromObj</B>
or <B>Tcl_GetString</B> should be treated as read-only.  It is
recommended that this pointer be assigned to a (const char *) variable.
Even in the limited situations where writing to this pointer is
acceptable, one should take care to respect the copy-on-write
semantics required by <B><A HREF="Object.html">Tcl_Obj</A></B>'s, with appropriate calls
to <B><A HREF="Object.html">Tcl_IsShared</A></B> and <B><A HREF="Object.html">Tcl_DuplicateObj</A></B> prior to any
in-place modification of the string representation.
The procedure <B>Tcl_GetString</B> is used in the common case
where the caller does not need the length of the string
representation.
<P>
<B>Tcl_GetUnicodeFromObj</B> and <B>Tcl_GetUnicode</B> return a value's
value as a Unicode string.  This is given by the returned pointer and
(for <B>Tcl_GetUnicodeFromObj</B>) length, which is stored in
<I>lengthPtr</I> if it is non-NULL.  The storage referenced by the returned
byte pointer is owned by the value manager and should not be modified by
the caller.  The procedure <B>Tcl_GetUnicode</B> is used in the common case
where the caller does not need the length of the unicode string
representation.
<P>
<B>Tcl_GetUniChar</B> returns the <I>index</I>'th character in the
value's Unicode representation.
<P>
<B>Tcl_GetRange</B> returns a newly created value comprised of the
characters between <I>first</I> and <I>last</I> (inclusive) in the
value's Unicode representation.  If the value's Unicode
representation is invalid, the Unicode representation is regenerated
from the value's string representation.
<P>
<B>Tcl_GetCharLength</B> returns the number of characters (as opposed
to bytes) in the string value.
<P>
<B>Tcl_AppendToObj</B> appends the data given by <I>bytes</I> and
<I>length</I> to the string representation of the value specified by
<I>objPtr</I>.  If the value has an invalid string representation,
then an attempt is made to convert <I>bytes</I> is to the Unicode
format.  If the conversion is successful, then the converted form of
<I>bytes</I> is appended to the value's Unicode representation.
Otherwise, the value's Unicode representation is invalidated and
converted to the UTF format, and <I>bytes</I> is appended to the
value's new string representation.
<P>
<B>Tcl_AppendUnicodeToObj</B> appends the Unicode string given by
<I>unicode</I> and <I>numChars</I> to the value specified by
<I>objPtr</I>.  If the value has an invalid Unicode representation,
then <I>unicode</I> is converted to the UTF format and appended to the
value's string representation.  Appends are optimized to handle
repeated appends relatively efficiently (it over-allocates the string
or Unicode space to avoid repeated reallocations and copies of
value's string value).
<P>
<B>Tcl_AppendObjToObj</B> is similar to <B>Tcl_AppendToObj</B>, but it
appends the string or Unicode value (whichever exists and is best
suited to be appended to <I>objPtr</I>) of <I>appendObjPtr</I> to
<I>objPtr</I>.
<P>
<B>Tcl_AppendStringsToObj</B> is similar to <B>Tcl_AppendToObj</B>
except that it can be passed more than one value to append and
each value must be a null-terminated string (i.e. none of the
values may contain internal null characters).  Any number of
<I>string</I> arguments may be provided, but the last argument
must be a NULL pointer to indicate the end of the list.
<P>
<B>Tcl_AppendStringsToObjVA</B> is the same as <B>Tcl_AppendStringsToObj</B>
except that instead of taking a variable number of arguments it takes an
argument list.
<P>
<B>Tcl_AppendLimitedToObj</B> is similar to <B>Tcl_AppendToObj</B>
except that it imposes a limit on how many bytes are appended.
This can be handy when the string to be appended might be
very large, but the value being constructed should not be allowed to grow
without bound. A common usage is when constructing an error message, where the
end result should be kept short enough to be read.
Bytes from <I>bytes</I> are appended to <I>objPtr</I>, but no more
than <I>limit</I> bytes total are to be appended. If the limit prevents
all <I>length</I> bytes that are available from being appended, then the
appending is done so that the last bytes appended are from the
string <I>ellipsis</I>. This allows for an indication of the truncation
to be left in the string.
When <I>length</I> is <B>-1</B>, all bytes up to the first zero byte are appended,
subject to the limit. When <I>ellipsis</I> is NULL, the default
string <B>...</B> is used. When <I>ellipsis</I> is non-NULL, it must point
to a zero-byte-terminated string in Tcl's internal UTF encoding.
The number of bytes appended can be less than the lesser
of <I>length</I> and <I>limit</I> when appending fewer
bytes is necessary to append only whole multi-byte characters.
<P>
<B>Tcl_Format</B> is the C-level interface to the engine of the <B><A HREF="../TclCmd/format.html">format</A></B>
command.  The actual command procedure for <B><A HREF="../TclCmd/format.html">format</A></B> is little more
than
<P>
<PRE><B>Tcl_Format</B>(interp, <B>Tcl_GetString</B>(objv[1]), objc-2, objv+2);</PRE>
<P>
The <I>objc</I> <A HREF="Object.html">Tcl_Obj</A> values in <I>objv</I> are formatted into a string
according to the conversion specification in <I>format</I> argument, following
the documentation for the <B><A HREF="../TclCmd/format.html">format</A></B> command.  The resulting formatted
string is converted to a new <A HREF="Object.html">Tcl_Obj</A> with refcount of zero and returned.
If some error happens during production of the formatted string, NULL is
returned, and an error message is recorded in <I>interp</I>, if <I>interp</I>
is non-NULL.
<P>
<B>Tcl_AppendFormatToObj</B> is an appending alternative form
of <B>Tcl_Format</B> with functionality equivalent to:
<P>
<PRE><A HREF="Object.html">Tcl_Obj</A> *newPtr = <B>Tcl_Format</B>(interp, format, objc, objv);
if (newPtr == NULL) return TCL_ERROR;
<B>Tcl_AppendObjToObj</B>(objPtr, newPtr);
<B><A HREF="Object.html">Tcl_DecrRefCount</A></B>(newPtr);
return TCL_OK;</PRE>
<P>
but with greater convenience and efficiency when the appending
functionality is needed.
<P>
<B>Tcl_ObjPrintf</B> serves as a replacement for the common sequence
<P>
<PRE>char buf[SOME_SUITABLE_LENGTH];
sprintf(buf, format, ...);
<B>Tcl_NewStringObj</B>(buf, -1);</PRE>
<P>
but with greater convenience and no need to
determine <B>SOME_SUITABLE_LENGTH</B>. The formatting is done with the same
core formatting engine used by <B>Tcl_Format</B>.  This means the set of
supported conversion specifiers is that of the <B><A HREF="../TclCmd/format.html">format</A></B> command and
not that of the <B>sprintf</B> routine where the two sets differ. When a
conversion specifier passed to <B>Tcl_ObjPrintf</B> includes a precision,
the value is taken as a number of bytes, as <B>sprintf</B> does, and not
as a number of characters, as <B><A HREF="../TclCmd/format.html">format</A></B> does.  This is done on the
assumption that C code is more likely to know how many bytes it is
passing around than the number of encoded characters those bytes happen
to represent.  The variable number of arguments passed in should be of
the types that would be suitable for passing to <B>sprintf</B>.  Note in
this example usage, <I>x</I> is of type <B>int</B>.
<P>
<PRE>int x = 5;
<A HREF="Object.html">Tcl_Obj</A> *objPtr = <B>Tcl_ObjPrintf</B>(&quot;Value is %d&quot;, x);</PRE>
<P>
If the value of <I>format</I> contains internal inconsistencies or invalid
specifier formats, the formatted string result produced by
<B>Tcl_ObjPrintf</B> will be an error message describing the error.
It is impossible however to provide runtime protection against
mismatches between the format and any subsequent arguments.
Compile-time protection may be provided by some compilers.
<P>
<B>Tcl_AppendPrintfToObj</B> is an appending alternative form
of <B>Tcl_ObjPrintf</B> with functionality equivalent to
<P>
<PRE><A HREF="Object.html">Tcl_Obj</A> *newPtr = <B>Tcl_ObjPrintf</B>(format, ...);
<B>Tcl_AppendObjToObj</B>(objPtr, newPtr);
<B><A HREF="Object.html">Tcl_DecrRefCount</A></B>(newPtr);</PRE>
<P>
but with greater convenience and efficiency when the appending
functionality is needed.
<P>
The <B>Tcl_SetObjLength</B> procedure changes the length of the
string value of its <I>objPtr</I> argument.  If the <I>newLength</I>
argument is greater than the space allocated for the value's
string, then the string space is reallocated and the old value
is copied to the new space; the bytes between the old length of
the string and the new length may have arbitrary values.
If the <I>newLength</I> argument is less than the current length
of the value's string, with <I>objPtr-&gt;length</I> is reduced without
reallocating the string space; the original allocated size for the
string is recorded in the value, so that the string length can be
enlarged in a subsequent call to <B>Tcl_SetObjLength</B> without
reallocating storage.  In all cases <B>Tcl_SetObjLength</B> leaves
a null character at <I>objPtr-&gt;bytes[newLength]</I>.
<P>
<B>Tcl_AttemptSetObjLength</B> is identical in function to
<B>Tcl_SetObjLength</B> except that if sufficient memory to satisfy the
request cannot be allocated, it does not cause the Tcl interpreter to
<B>panic</B>.  Thus, if <I>newLength</I> is greater than the space
allocated for the value's string, and there is not enough memory
available to satisfy the request, <B>Tcl_AttemptSetObjLength</B> will take
no action and return 0 to indicate failure.  If there is enough memory
to satisfy the request, <B>Tcl_AttemptSetObjLength</B> behaves just like
<B>Tcl_SetObjLength</B> and returns 1 to indicate success.
<P>
The <B>Tcl_ConcatObj</B> function returns a new string value whose
value is the space-separated concatenation of the string
representations of all of the values in the <I>objv</I>
array. <B>Tcl_ConcatObj</B> eliminates leading and trailing white space
as it copies the string representations of the <I>objv</I> array to the
result. If an element of the <I>objv</I> array consists of nothing but
white space, then that value is ignored entirely. This white-space
removal was added to make the output of the <B><A HREF="../TclCmd/concat.html">concat</A></B> command
cleaner-looking. <B>Tcl_ConcatObj</B> returns a pointer to a
newly-created value whose ref count is zero.
<H3><A NAME="M6">SEE ALSO</A></H3>
<B><A HREF="Object.html">Tcl_NewObj</A></B>, <B><A HREF="Object.html">Tcl_IncrRefCount</A></B>, <B><A HREF="Object.html">Tcl_DecrRefCount</A></B>, <B><A HREF="../TclCmd/format.html">format</A></B>, <B>sprintf</B>
<H3><A NAME="M7">KEYWORDS</A></H3>
<A href="../Keywords/A.html#append">append</A>, <A href="../Keywords/I.html#internal representation">internal representation</A>, <A href="../Keywords/V.html#value">value</A>, <A href="../Keywords/V.html#value type">value type</A>, <A href="../Keywords/S.html#string value">string value</A>, <A href="../Keywords/S.html#string type">string type</A>, <A href="../Keywords/S.html#string representation">string representation</A>, <A href="../Keywords/C.html#concat">concat</A>, <A href="../Keywords/C.html#concatenate">concatenate</A>, <A href="../Keywords/U.html#unicode">unicode</A>
<div class="copy">Copyright &copy; 1994-1997 Sun Microsystems, Inc.
</div>
</BODY></HTML>


			<aside class="copyright" role="note">
				
				Documentation built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>

			<footer class="footer">
				<div class="as_footer">
  
  <div class="prod_links">
    <strong>
      <a href="http://platform.activestate.com/" target="_blank">ActiveState Platform</a>&nbsp;&nbsp;
      <a href="http://www.activestate.com/downloads" target="_blank">Downloads</a>&nbsp;&nbsp;
      <a href="http://community.activestate.com/" target="_blank">Community</a>&nbsp;&nbsp;
      <a href="http://github.com/activestate/code" target="_blank">Code Recipes</a>&nbsp;&nbsp;
    </strong>
  </div>
  <div class="as_copyright"> 
    &copy; 2019 ActiveState Software Inc. All rights reserved. <strong><a href="../../trademarks/index.html">Trademarks</a>. <a href="http://www.activestate.com/privacy-policy">Privacy Policy</a>.</strong>
  </div>
</div>

			</footer>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = '';
      var repo_id  = '';
    
    </script>

    <script src="../../javascripts/application.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var headers   = document.getElementsByTagName("h2");
      var scrollspy = document.getElementById('scrollspy');

      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;

            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }


        /* Add permanent link next to the headers */
        var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

        for(var i = 0; i < headers.length; i++) {
            var a = document.createElement("a");
            a.setAttribute("class", "headerlink");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", "Permanent link")
            a.innerHTML = "¶";
            headers[i].appendChild(a);
        }
      }
    </script>

    
      <script>
        (function(i,s,o,g,r,a,m){
          i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||
          []).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;
          m.parentNode.insertBefore(a,m)
        })(window, document,
          'script', '//www.google-analytics.com/analytics.js', 'ga');
         
        ga('create', 'UA-20072-24', 'auto');
        ga('set', 'anonymizeIp', true);
        ga('send', 'pageview');
         
        var buttons = document.querySelectorAll('a');
        Array.prototype.map.call(buttons, function(item) {
          if (item.host != document.location.host) {
            item.addEventListener('click', function() {
              var action = item.getAttribute('data-action') || 'follow';
              ga('send', 'event', 'outbound', action, item.href);
            });
          }
        });
         
        var query = document.querySelector('.query');
        query.addEventListener('blur', function() {
          if (this.value) {
            var path = document.location.pathname;
            ga('send', 'pageview', path + '?q=' + this.value);
          }
        });
      </script>
    

    <script src="../../javascripts/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

