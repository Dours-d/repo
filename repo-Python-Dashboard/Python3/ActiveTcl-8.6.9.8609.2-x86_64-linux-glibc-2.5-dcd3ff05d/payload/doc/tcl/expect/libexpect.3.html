<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="en-us">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=10" />
    <title>ActiveTcl 8.6.9 Documentation</title>
    <meta name="generator" content="Hugo 0.26" />

    
    <meta name="description" content="Complete documentation for ActiveTcl 8.6.9">
    
    <link rel="canonical" href="libexpect.3.html">
    

    
    <meta name="apple-mobile-web-app-title" content="ActiveTcl 8.6.9 Documentation">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="../../images/favicon.ico">
    <link rel="icon" type="image/x-icon" href="../../images/favicon.ico">

    <style>
      @font-face {
        font-family: 'Icon';
        src: url('../../fonts/icon.eot');
        src: url('../../fonts/icon.eot')
               format('embedded-opentype'),
             url('../../fonts/icon.woff')
               format('woff'),
             url('../../fonts/icon.ttf')
               format('truetype'),
             url('../../fonts/icon.svg')
               format('svg');
        font-weight: normal;
        font-style: normal;
      }
    </style>

    <link rel="stylesheet" href="../../stylesheets/application.css">
    <link rel="stylesheet" href="../../stylesheets/temporary.css">
    <link rel="stylesheet" href="../../stylesheets/palettes.css">
    <link rel="stylesheet" href="../../stylesheets/highlight/highlight.css">

    
    
    
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open%20Sans:400,700|Source+Code+Pro">
    <style>
      body, input {
        font-family: 'Open Sans', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Source Code Pro', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <link rel="stylesheet" href="../../stylesheets/as_common.css">
    
    <link rel="stylesheet" href="../../stylesheets/as_custom.css">
    
    <script src="../../javascripts/modernizr.js"></script>

    

  </head>
  <body class="palette-primary-grey palette-accent-red">




<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="logo">
        <a href="http://www.activestate.com/">
          <img src="../../images/logo.png" alt="ActiveState homepage">
        </a>
      </div>
      <div class="title">
        <a href="http://docs.activestate.com/">docs.activestate.com</a>
      </div>
    </div>

    

    
    
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>

</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="../../index.html" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="../../images/as_tcl.png">
        </div>
      
      <div class="name">
        <strong>ActiveTcl 8.6.9 Documentation </strong>
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      

      <div class="toc">
        
        <ul>
          




<li>
  



<a  title="Get ActiveTcl" href="../../get/index.html">
	
	Get ActiveTcl
</a>



  
    <ul>
      
        
        



<a  title="Release notes" href="../../get/relnotes/index.html">
	
	Release notes
</a>



      
        
        



<a  title="Windows installation" href="../../get/windows/index.html">
	
	Windows installation
</a>



      
        
        



<a  title="Linux/Unix Installaton" href="../../get/linux/index.html">
	
	Linux/Unix Installaton
</a>



      
        
        



<a  title="macOS Installation" href="../../get/macos/index.html">
	
	macOS Installation
</a>



      
        
        



<a  title="License" href="../../get/license/index.html">
	
	License
</a>



      
    </ul>
  
</li>



<li>
  



<a  title="Get Started" href="../../start/index.html">
	
	Get Started
</a>



  
    <ul>
      
        
        



<a  title="Package Reference" href="../../pkg/index.html">
	
	Package Reference
</a>



      
        
        



<a  title="Tcl 8.6.9 docs" href="../contents.html">
	
	Tcl 8.6.9 docs
</a>



      
    </ul>
  
</li>



<li>
  



<a  title="Contact Us" href="../../contact/index.html">
	
	Contact Us
</a>



  
</li>


        </ul>
        

        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1> </h1>

			<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- manual page source format generated by PolyglotMan v3.0.8+X.Org, -->
<!-- available at http://polyglotman.sourceforge.net/ -->
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta name='Author' content='ActiveState'>

<title>libexpect</title>
</head>
<body>
<a href='libexpect.3.html#toc'>Table of Contents</a>

<h2><a name='sect0' href='libexpect.3.html#toc0'>Name</a></h2>

<p>libexpect - programmed dialogue library with interactive
programs</p>

<h2><a name='sect1' href='libexpect.3.html#toc1'><b>Description</b></a></h2>

<p>This library contains functions that allow Expect to be used as
a Tcl extension or to be used directly from C or C++ (without Tcl).
Adding Expect as a Tcl extension is very short and simple, so that
will be covered first.</p>

<h2><a name='sect2' href='libexpect.3.html#toc2'><b>Synopsis</b></a></h2>

<p><b>#include</b> <b>expect_tcl.h</b><br>
 <b>Expect_Init(interp);</b></p>

<p><b>cc</b> <b>files...</b> <b>-lexpect5.20</b> <b>-ltcl7.5</b>
<b>-lm</b></p>

<p>Note: library versions may differ in the actual release.</p>

<p>The Expect_Init function adds expect commands to the named
interpreter. It avoids overwriting commands that already exist,
however aliases beginning with exp_ are always created for expect
commands. So for example, send can be used as exp_send".</p>

<p>Generally, you should only call Expect commands via Tcl_Eval.
Certain auxiliary functions may be called directly. They are
summarized below. They may be useful in constructing your own main.
Look at the file exp_main_exp.c in the Expect distribution as a
prototype main. Another prototype is tclAppInit.c in the Tcl source
distribution. A prototype for working with Tk is in exp_main_tk.c
in the Expect distribution.</p>

<p>int exp_cmdlinecmds;<br>
 int exp_interactive;<br>
 FILE *exp_cmdfile;<br>
 char *exp_cmdfilename;<br>
 int exp_tcl_debugger_available;</p>

<p>void exp_parse_argv(Tcl_Interp *,int argc,char **argv); int
exp_interpreter(Tcl_Interp *);<br>
 void exp_interpret_cmdfile(Tcl_Interp *,FILE *); void
exp_interpret_cmdfilename(Tcl_Interp *,char *); void
exp_interpret_rcfiles(Tcl_Interp *,int my_rc,int sys_rc);</p>

<dl>
<dt>char *</dt>

<dd>exp_cook(char *s,int *len); void
(*exp_app_exit)EXP_PROTO((Tcl_Interp *); void exp_exit(Tcl_Interp
*,int status); void exp_exit_handlers(Tcl_Interp *); void
exp_error(Tcl_Interp,char *,...);</dd>
</dl>

<p><b>exp_cmdlinecmds</b> is 1 if Expect has been invoked with
commands on the program command-line (using -c for example).
<b>exp_interactive</b> is 1 if Expect has been invoked with the -i
flag or if no commands or script is being invoked.
<b>exp_cmdfile</b> is a stream from which Expect will read
commands. <b>exp_cmdfilename</b> is the name of a file which Expect
will open and read commands from. <b>exp_tcl_debugger_available</b>
is 1 if the debug-ger has been armed.</p>

<p><b>exp_parse_argv</b> reads the representation of the command
line. Based on what is found, any of the other variables listed
here are initialized appropriately. <b>exp_interpreter</b>
interactively prompts the user for com-mands and evaluates them.
<b>exp_interpret_cmdfile</b> reads the given stream and evaluates
any commands found. <b>exp_interpret_cmdfilename</b> opens the
named file and evaluates any commands found.
<b>exp_interpret_rcfiles</b> reads and evalutes the .rc files. If
my_rc is zero, then ~/.expectrc is skipped. If sys_rc is zero, then
the system-wide expectrc file is skipped. <b>exp_cook</b> returns a
static buffer containing the argument reproduced with newlines
replaced by carriage-return linefeed sequences. The primary purpose
of this is to allow messages to be pro-duced without worrying about
whether the terminal is in raw mode or cooked mode. If length is
zero, it is computed via strlen. <b>exp_error</b> <b>is</b>
<b>a</b> <b>printf-like</b> <b>function</b> <b>that</b>
<b>writes</b> <b>the</b> <b>result</b> to interp-&gt;result.</p>

<h2><a name='sect3' href='libexpect.3.html#toc3'><b>Synopsis</b></a></h2>

<p><b>#include</b> <b>&lt;expect.h&gt;</b></p>

<p><b>int</b><br>
 <b>exp_spawnl(file,</b> <b>arg0</b> <b>[,</b> <b>arg1,</b>
<b>...,</b> <b>argn]</b> <b>(char</b> <b>*)0);</b> <b>char</b>
<b>*file;</b><br>
 <b>char</b> <b>*arg0,</b> <b>*arg1,</b> <b>...</b>
<b>*argn;</b></p>

<p><b>int</b><br>
 <b>exp_spawnv(file,argv);</b><br>
 <b>char</b> <b>*file,</b> <b>*argv[</b> <b>];</b></p>

<p><b>int</b><br>
 <b>exp_spawnfd(fd);</b><br>
 <b>int</b> <b>fd;</b></p>

<dl>
<dt><b>FILE</b> <b>*</b></dt>

<dd><b>exp_popen(command);</b> <b>char</b> <b>*command;</b></dd>
</dl>

<p><b>extern</b> <b>int</b> <b>exp_pid;</b><br>
 <b>extern</b> <b>int</b> <b>exp_ttyinit;</b><br>
 <b>extern</b> <b>int</b> <b>exp_ttycopy;</b><br>
 <b>extern</b> <b>int</b> <b>exp_console;</b><br>
 <b>extern</b> <b>char</b> <b>*exp_stty_init;</b><br>
 <b>extern</b> <b>void</b> <b>(*exp_close_in_child)();</b><br>
 <b>extern</b> <b>void</b> <b>(*exp_child_exec_prelude)();</b><br>
 <b>extern</b> <b>void</b> <b>exp_close_tcl_files();</b></p>

<p><b>cc</b> <b>files...</b> <b>-lexpect</b> <b>-ltcl</b>
<b>-lm</b></p>

<h2><a name='sect4' href='libexpect.3.html#toc4'><b>Description</b></a></h2>

<p><b>exp_spawnl</b> and <b>exp_spawnv</b> fork a new process so
that its stdin, stdout, and stderr can be written and read by the
current process. <i>file</i> is the name of a file to be executed.
The <i>arg</i> pointers are null-terminated strings. Following the
style of execve(), <i>arg0</i> (or <i>argv[0]</i>) is custom-arily
a duplicate of the name of the file.</p>

<p>Four interfaces are available, <b>exp_spawnl</b> is useful when
the number of arguments is known at compile time. <b>exp_spawnv</b>
is useful when the num-ber of arguments is not known at compile
time. <b>exp_spawnfd</b> is useful when an open file descriptor is
already available as a source. <b>exp_popen</b> is explained later
on.</p>

<p>If the process is successfully created, a file descriptor is
returned which corresponds to the process&acirc;&euro;&trade;s
stdin, stdout and stderr. A stream may be associated with the file
descriptor by using fdopen(). (This should almost certainly be
followed by setbuf() to unbuffer the I/O.)</p>

<p>Closing the file descriptor will typically be detected by the
process as an EOF. Once such a process exits, it should be waited
upon (via wait) in order to free up the kernel process slot. (Some
systems allow you to avoid this if you ignore the SIGCHLD
signal).</p>

<p><b>exp_popen</b> is yet another interface, styled after popen().
It takes a Bourne shell command line, and returns a stream that
corresponds to the process&acirc;&euro;&trade;s stdin, stdout and
stderr. The actual implementation of <b>exp_popen</b> below
demonstrates <b>exp_spawnl</b>.</p>

<dl>
<dt>FILE *</dt>

<dd><a href='http://localhost/activetcl/8.6/tcl/expect/exp_popen.p.html'>exp_popen(program)</a> char
*program; { FILE *fp; int ec;</dd>
</dl>

<p>if (0 &gt; (ec = exp_spawnl("sh","sh","-c",program,(char *)0)))
return(0);<br>
 if (NULL == (fp = fdopen(ec,"r+")) return(0); setbuf(fp,(char
*)0);<br>
 return(fp);<br>
 }</p>

<p>After a process is started, the variable <b>exp_pid</b> is set
to the process-id of the new process. The variable
<b>exp_pty_slave_name</b> is set to the name of the slave side of
the pty.</p>

<p>The spawn functions uses a pty to communicate with the process.
By default, the pty is initialized the same way as the
user&acirc;&euro;&trade;s tty (if pos-sible, i.e., if the
environment has a controlling terminal.) This ini-tialization can
be skipped by setting exp_ttycopy to 0.</p>

<p>The pty is further initialized to some system wide defaults if
exp_ttyinit is non-zero. The default is generally comparable to
stty sane".</p>

<p>The tty setting can be further modified by setting the variable
<b>exp_stty_init</b>. This variable is interpreted in the style of
stty argu-ments. For example, exp_stty_init = sane"; repeats the
default ini-tialization.</p>

<p>On some systems, it is possible to redirect console output to
ptys. If this is supported, you can force the next spawn to obtain
the console output by setting the variable <b>exp_console</b> to
1.</p>

<p>Between the time a process is started and the new program is
given con-trol, the spawn functions can clean up the environment by
closing file descriptors. By default, the only file descriptors
closed are ones internal to Expect and any marked
close-on-exec".</p>

<p>If needed, you can close additional file descriptors by creating
an appropriate function and assigning it to exp_close_in_child. The
func-tion will be called after the fork and before the exec. (This
also modifies the behavior of the spawn command in Expect.)</p>

<p>If you are also using Tcl, it may be convenient to use the
function exp_close_tcl_files which closes all files between the
default standard file descriptors and the highest descriptor known
to Tcl. (Expect does this.)</p>

<p>The function exp_child_exec_prelude is the last function called
prior to the actual exec in the child. You can redefine this for
effects such as manipulating the uid or the signals.</p>

<h2><a name='sect5' href='libexpect.3.html#toc5'><b>If</b> <b>You</b> <b>Want</b>
<b>to</b> <b>Allocate</b> <b>Your</b> <b>Own</b>
<b>Pty</b></a></h2>

<p><b>extern</b> <b>int</b> <b>exp_autoallocpty;</b><br>
 <b>extern</b> <b>int</b> <b>exp_pty[2];</b></p>

<p>The spawn functions use a pty to communicate with the process.
By default, a pty is automatically allocated each time a process is
spawned. If you want to allocate ptys yourself, before calling one
of the spawn functions, set <b>exp_autoallocpty</b> to 0,
<b>exp_pty[0]</b> to the mas-ter pty file descriptor and
<b>exp_pty[1]</b> to the slave pty file descriptor. The expect
library will not do any pty initializations (e.g., exp_stty_init
will not be used). The slave pty file descriptor will be
automatically closed when the process is spawned. After the process
is started, all further communication takes place with the mas-ter
pty file descriptor.</p>

<p><b>exp_spawnl</b> and <b>exp_spawnv</b> duplicate the
shell&acirc;&euro;&trade;s actions in searching for an executable
file in a list of directories. The directory list is obtained from
the environment.</p>

<h2><a name='sect6' href='libexpect.3.html#toc6'><b>Expect</b>
<b>Processing</b></a></h2>

<p>While it is possible to use read() to read information from a
process spawned by <b>exp_spawnl</b> or <b>exp_spawnv</b>, more
convenient functions are pro-vided. They are as follows:</p>

<p><b>int</b><br>
 <b>exp_expectl(fd,type1,pattern1,[re1,],value1,type2,...,exp_end);</b>
<b>int</b> <b>fd;</b><br>
 <b>enum</b> <b>exp_type</b> <b>type;</b><br>
 <b>char</b> <b>*pattern1,</b> <b>*pattern2,</b> <b>...;</b><br>
 <b>regexp</b> <b>*re1,</b> <b>*re2,</b> <b>...;</b><br>
 <b>int</b> <b>value1,</b> <b>value2,</b> <b>...;</b></p>

<p><b>int</b><br>
 <b>exp_fexpectl(fp,type1,pattern1,[re1,]value1,type2,...,exp_end);</b>
<b>FILE</b> <b>*fp;</b><br>
 <b>enum</b> <b>exp_type</b> <b>type;</b><br>
 <b>char</b> <b>*pattern1,</b> <b>*pattern2,</b> <b>...;</b><br>
 <b>regexp</b> <b>*re1,</b> <b>*re2,</b> <b>...;</b><br>
 <b>int</b> <b>value1,</b> <b>value2,</b> <b>...;</b></p>

<p><b>enum</b> <b>exp_type</b> <b>{</b><br>
 <b>exp_end,</b><br>
 <b>exp_glob,</b><br>
 <b>exp_exact,</b><br>
 <b>exp_regexp,</b><br>
 <b>exp_compiled,</b><br>
 <b>exp_null,</b><br>
 <b>};</b></p>

<p><b>struct</b> <b>exp_case</b> <b>{</b><br>
 <b>char</b> <b>*pattern;</b><br>
 <b>regexp</b> <b>*re;</b><br>
 <b>enum</b> <b>exp_type</b> <b>type;</b><br>
 <b>int</b> <b>value;</b><br>
 <b>};</b></p>

<p><b>int</b><br>
 <b>exp_expectv(fd,cases);</b><br>
 <b>int</b> <b>fd;</b><br>
 <b>struct</b> <b>exp_case</b> <b>*cases;</b></p>

<p><b>int</b><br>
 <b>exp_fexpectv(fp,cases);</b><br>
 <b>FILE</b> <b>*fp;</b><br>
 <b>struct</b> <b>exp_case</b> <b>*cases;</b></p>

<p><b>extern</b> <b>int</b> <b>exp_timeout;</b><br>
 <b>extern</b> <b>char</b> <b>*exp_match;</b><br>
 <b>extern</b> <b>char</b> <b>*exp_match_end;</b><br>
 <b>extern</b> <b>char</b> <b>*exp_buffer;</b><br>
 <b>extern</b> <b>char</b> <b>*exp_buffer_end;</b><br>
 <b>extern</b> <b>int</b> <b>exp_match_max;</b><br>
 <b>extern</b> <b>int</b> <b>exp_full_buffer;</b><br>
 <b>extern</b> <b>int</b> <b>exp_remove_nulls;</b></p>

<p>The functions wait until the output from a process matches one
of the patterns, a specified time period has passed, or an EOF is
seen.</p>

<p>The first argument to each function is either a file descriptor
or a stream. Successive sets of arguments describe patterns and
associated integer values to return when the pattern matches.</p>

<p>The type argument is one of four values. exp_end indicates that
no more patterns appear. exp_glob indicates that the pattern is a
glob-style string pattern. exp_exact indicates that the pattern is
an exact string. exp_regexp indicates that the pattern is a
regexp-style string pattern. exp_compiled indicates that the
pattern is a regexp-style string pattern, and that its compiled
form is also provided. exp_null indicates that the pattern is a
null (for debugging purposes, a string pattern must also
follow).</p>

<p>If the compiled form is not provided with the functions
<b>exp_expectl</b> and <b>exp_fexpectl</b>, any pattern compilation
done internally is thrown away after the function returns. The
functions <b>exp_expectv</b> and <b>exp_fexpectv</b> will
automatically compile patterns and will not throw them away.
Instead, they must be discarded by the user, by calling free on
each pattern. It is only necessary to discard them, the last time
the cases are used.</p>

<p>Regexp subpatterns matched are stored in the compiled regexp.
Assuming re contains a compiled regexp, the matched string can be
found in re-&gt;startp[0]. The match substrings (according to the
parentheses) in the original pattern can be found in
re-&gt;startp[1], re-&gt;startp[2], and so on, up to
re-&gt;startp[9]. The corresponding strings ends are re-&gt;endp[x]
where x is that same index as for the string start.</p>

<p>The type exp_null matches if a null appears in the input. The
variable exp_remove_nulls must be set to 0 to prevent nulls from
being automati-cally stripped. By default, exp_remove_nulls is set
to 1 and nulls are automatically stripped.</p>

<p><b>exp_expectv</b> and <b>exp_fexpectv</b> are useful when the
number of patterns is not known in advance. In this case, the sets
are provided in an array. The end of the array is denoted by a
struct exp_case with type exp_end. For the rest of this discussion,
these functions will be referred to generically as
<i>expect.</i></p>

<p>If a pattern matches, then the corresponding integer value is
returned. Values need not be unique, however they should be
positive to avoid being mistaken for EXP_EOF, EXP_TIMEOUT, or
EXP_FULLBUFFER. Upon EOF or timeout, the value <b>EXP_EOF</b> or
<b>EXP_TIMEOUT</b> is returned. The default timeout period is 10
seconds but may be changed by setting the variable
<b>exp_timeout</b>. A value of -1 disables a timeout from
occurring. A value of 0 causes the expect function to return
immediately (i.e., poll) after one read(). However it must be
preceded by a function such as select, poll, or an event manager
callback to guarantee that there is data to be read.</p>

<p>If the variable exp_full_buffer is 1, then EXP_FULLBUFFER is
returned if exp_buffer fills with no pattern having matched.</p>

<p>When the expect function returns, <b>exp_buffer</b> points to
the buffer of characters that was being considered for matching.
<b>exp_buffer_end</b> points to one past the last character in
exp_buffer. If a match occurred, <b>exp_match</b> points into
<b>exp_buffer</b> where the match began. <b>exp_match_end</b>
points to one character past where the match ended.</p>

<p>Each time new input arrives, it is compared to each pattern in
the order they are listed. Thus, you may test for absence of a
match by making the last pattern something guaranteed to appear,
such as a prompt. In situations where there is no prompt, you must
check for <b>EXP_TIMEOUT</b> (just like you would if you were
interacting manually). More philosophy and strategies on specifying
<b>expect</b> patterns can be found in the documentation on the
<b>expect</b> program itself. See SEE ALSO below.</p>

<p>Patterns are the usual C-shell-style regular expressions. For
example, the following fragment looks for a successful login, such
as from a telnet dialogue.</p>

<p>switch (exp_expectl(<br>
 exp_glob,"connected",CONN,<br>
 exp_glob,"busy",BUSY,<br>
 exp_glob,"failed",ABORT,<br>
 exp_glob,"invalid password",ABORT, exp_end)) {<br>
</p>

<dl>
<dt>case CONN:</dt>

<dd>/* logged in successfully */ break;</dd>

<dt>case BUSY:</dt>

<dd>/* couldn&acirc;&euro;&trade;t log in at the moment */ break;
case EXP_TIMEOUT:</dd>

<dt>case ABORT:</dt>

<dd>/* can&acirc;&euro;&trade;t log in at any moment! */ break;
default: /* problem with expect */ }</dd>
</dl>

<p>Asterisks (as in the example above) are a useful shorthand for
omitting line-termination characters and other detail. Patterns
must match the entire output of the current process (since the
previous read on the descriptor or stream). More than 2000 bytes of
output can force ear-lier bytes to be forgotten". This may be
changed by setting the vari-able <b>exp_match_max</b>. Note that
excessively large values can slow down the pattern matcher.</p>

<h2><a name='sect7' href='libexpect.3.html#toc7'><b>Running</b> <b>in</b>
<b>the</b> <b>Background</b></a></h2>

<p><b>extern</b> <b>int</b> <b>exp_disconnected;</b><br>
 <b>int</b> <b>exp_disconnect();</b></p>

<p>It is possible to move a process into the background after it
has begun running. A typical use for this is to read passwords and
then go into the background to sleep before using the passwords to
do real work.</p>

<p>To move a process into the background, fork, call
exp_disconnect() in the child process and exit() in the parent
process. This disassociates your process from the controlling
terminal. If you wish to move a pro-cess into the background in a
different way, you must set the variable exp_disconnected to 1.
This allows processes spawned after this point to be started
correctly.</p>

<h2><a name='sect8' href='libexpect.3.html#toc8'><b>Multiplexing</b></a></h2>

<p>By default, the expect functions block inside of a read on a
single file descriptor. If you want to wait on patterns from
multiple file descriptors, use select, poll, or an event manager.
They will tell you what file descriptor is ready to read.</p>

<p>When a file descriptor is ready to read, you can use the expect
func-tions to do one and only read by setting timeout to 0.</p>

<h2><a name='sect9' href='libexpect.3.html#toc9'><b>Slave</b>
<b>Control</b></a></h2>

<p><b>void</b><br>
 <b>exp_slave_control(fd,enable)</b><br>
 <b>int</b> <b>fd;</b><br>
 <b>int</b> <b>enable;</b></p>

<p>Pty trapping is normally done automatically by the expect
functions. However, if you want to issue an ioctl, for example,
directly on the slave device, you should temporary disable
trapping.</p>

<p>Pty trapping can be controlled with exp_slave_control. The first
argu-ment is the file descriptor corresponding to the spawned
process. The second argument is a 0 if trapping is to be disabled
and 1 if it is to be enabled.</p>

<h2><a name='sect10' href='libexpect.3.html#toc10'><b>Errors</b></a></h2>

<p>All functions indicate errors by returning -1 and setting
errno.</p>

<p>Errors that occur after the spawn functions fork (e.g.,
attempting to spawn a non-existent program) are written to the
process&acirc;&euro;&trade;s stderr, and will be read by the first
<b>expect</b>.</p>

<h2><a name='sect11' href='libexpect.3.html#toc11'><b>Signals</b></a></h2>

<p><b>extern</b> <b>int</b> <b>exp_reading;</b><br>
 <b>extern</b> <b>jmp_buf</b> <b>exp_readenv;</b></p>

<p><b>expect</b> uses alarm() to timeout, thus if you generate
alarms during <b>expect</b>, it will timeout prematurely.</p>

<p>Internally, <b>expect</b> calls read() which can be interrupted
by signals. If you define signal handlers, you can choose to
restart or abort <b>expect</b>&acirc;&euro;&trade;s internal read.
The variable, <b>exp_reading</b>, is true if (and only if)
<b>expect</b>&acirc;&euro;&trade;s read has been interrupted.
longjmp(exp_read-env,EXP_ABORT) will abort the read.
longjmp(exp_readenv,EXP_RESTART) will restart the read.</p>

<h2><a name='sect12' href='libexpect.3.html#toc12'><b>Logging</b></a></h2>

<p><b>extern</b> <b>int</b> <b>exp_loguser;</b><br>
 <b>extern</b> <b>int</b> <b>exp_logfile_all</b><br>
 <b>extern</b> <b>FILE</b> <b>*exp_logfile;</b></p>

<p>If <b>exp_loguser</b> is nonzero, <b>expect</b> sends any output
from the spawned process to stdout. Since interactive programs
typically echo their input, this usually suffices to show both
sides of the conversation. If <b>exp_logfile</b> is also nonzero,
this same output is written to the stream defined by
<b>exp_logfile</b>. If <b>exp_logfile_all</b> is non-zero,
<b>exp_logfile</b> is written regardless of the value of
<b>exp_loguser</b>.</p>

<h2><a name='sect13' href='libexpect.3.html#toc13'><b>Debugging</b></a></h2>

<p>While I consider the library to be easy to use, I think that the
stan-dalone expect program is much, much, easier to use than
working with the C compiler and its usual edit, compile, debug
cycle. Unlike typi-cal C programs, most of the debugging
isn&acirc;&euro;&trade;t getting the C compiler to accept your
programs - rather, it is getting the dialogue correct. Also,
translating scripts from expect to C is usually not necessary. For
example, the speed of interactive dialogues is virtually never an
issue. So please try the standalone
&acirc;&euro;&trade;expect&acirc;&euro;&trade; program first. I
suspect it is a more appropriate solution for most people than the
library.</p>

<p>Nonetheless, if you feel compelled to debug in C, here are some
tools to help you.</p>

<p><b>extern</b> <b>int</b> <b>exp_is_debugging;</b><br>
 <b>extern</b> <b>FILE</b> <b>*exp_debugfile;</b></p>

<p>While expect dialogues seem very intuitive, trying to codify
them in a program can reveal many surprises in a
program&acirc;&euro;&trade;s interface. Therefore a variety of
debugging aids are available. They are controlled by the above
variables, all 0 by default.</p>

<p>Debugging information internal to <b>expect</b> is sent to
stderr when <b>exp_is_debugging</b> is non-zero. The debugging
information includes every character received, and every attempt
made to match the current input against the patterns. In addition,
non-printable characters are trans-lated to a printable form. For
example, a control-C appears as a caret followed by a C. If
<b>exp_logfile</b> is non-zero, this information is also written to
that stream.</p>

<p>If <b>exp_debugfile</b> is non-zero, all normal and debugging
information is written to that stream, regardless of the value of
<b>exp_is_debugging</b>.</p>

<h2><a name='sect14' href='libexpect.3.html#toc14'><b>Caveats</b></a></h2>

<p>The stream versions of the <b>expect</b> functions are much
slower than the file descriptor versions because there is no way to
portably read an unknown number of bytes without the potential of
timing out. Thus, characters are read one at a time. You are
therefore strongly encour-aged to use the file descriptor versions
of <b>expect</b> (although, automated versions of interactive
programs don&acirc;&euro;&trade;t usually demand high speed
any-way).</p>

<p>You can actually get the best of both worlds, writing with the
usual stream functions and reading with the file descriptor
versions of <b>expect</b> as long as you don&acirc;&euro;&trade;t
attempt to intermix other stream input functions (e.g., fgetc). To
do this, pass fileno(stream) as the file descriptor each time.
Fortunately, there is little reason to use any-thing but the
<b>expect</b> functions when reading from interactive programs.</p>

<p>There is no matching exp_pclose to exp_popen (unlike popen and
pclose). It only takes two functions to close down a connection
(fclose() fol-lowed by waiting on the pid), but it is not uncommon
to separate these two actions by large time intervals, so the
function seems of little value.</p>

<p>If you are running on a Cray running Unicos (all I know for sure
from experience), you must run your compiled program as root or
setuid. The problem is that the Cray only allows root processes to
open ptys. You should observe as much precautions as possible: If
you don&acirc;&euro;&trade;t need per-missions, setuid(0) only
immediately before calling one of the spawn functions and
immediately set it back afterwards.</p>

<p>Normally, <b>spawn</b> takes little time to execute. If you
notice spawn tak-ing a significant amount of time, it is probably
encountering ptys that are wedged. A number of tests are run on
ptys to avoid entanglements with errant processes. (These take 10
seconds per wedged pty.) Run-ning expect with the -d option will
show if <b>expect</b> is encountering many ptys in odd states. If
you cannot kill the processes to which these ptys are attached,
your only recourse may be to reboot.</p>

<h2><a name='sect15' href='libexpect.3.html#toc15'><b>Bugs</b></a></h2>

<p>The <b>exp_fexpect</b> functions don&acirc;&euro;&trade;t work
at all under HP-UX - it appears to be a bug in getc. Follow the
advice (above) about using the <b>exp_expect</b> functions (which
doesn&acirc;&euro;&trade;t need to call getc). If you fix the
problem (before I do - please check the latest release) let me
know.</p>

<h2><a name='sect16' href='libexpect.3.html#toc16'><b>See</b> <b>Also</b></a></h2>

<p>An alternative to this library is the <b>expect</b> program.
<b>expect</b> inter-prets scripts written in a high-level language
which direct the dia-logue. In addition, the user can take control
and interact directly when desired. If it is not absolutely
necessary to write your own C program, it is much easier to use
<b>expect</b> to perform the entire interac-tion. It is described
further in the following references:</p>

<p><i>expect:</i> <i>Curing</i> <i>Those</i> <i>Uncontrollable</i>
<i>Fits</i> <i>of</i> <i>Interactivity</i> by Don Libes,
Proceedings of the Summer 1990 USENIX Conference, Anaheim,
Cali-fornia, June 11-15, 1990.</p>

<p><i>Using</i> <i>expect</i> <i>to</i> <i>Automate</i>
<i>System</i> <i>Administration</i> <i>Tasks</i> by Don Libes,
Proceedings of the 1990 USENIX Large Installation Systems
Administration Conference, Colorado Springs, Colorado, October
17-19, 1990.</p>

<p><a href='expect.1.html'>expect(1)</a> , <a href=
'http://localhost/activetcl/8.6/tcl/expect/alarm.3.html'>alarm(3)</a> , <a href='http://localhost/activetcl/8.6/tcl/expect/read.2.html'>read(2)</a> ,
<a href='http://localhost/activetcl/8.6/tcl/expect/write.2.html'>write(2)</a> , <a href=
'http://localhost/activetcl/8.6/tcl/expect/fdopen.3.html'>fdopen(3)</a> , <a href=
'http://localhost/activetcl/8.6/tcl/expect/execve.2.html'>execve(2)</a> , <a href=
'http://localhost/activetcl/8.6/tcl/expect/execvp.3.html'>execvp(3)</a> , <a href=
'http://localhost/activetcl/8.6/tcl/expect/longjmp.3.html'>longjmp(3)</a> , <a href='http://localhost/activetcl/8.6/tcl/expect/pty.4.html'>pty(4)</a>
.</p>

<p>There are several examples C programs in the test directory of
<b>expect</b>&acirc;&euro;&trade;s source distribution which use
the expect library.</p>

<h2><a name='sect17' href='libexpect.3.html#toc17'><b>Author</b></a></h2>

<p>Don Libes, libes@nist.gov, National Institute of Standards and
Technol-ogy</p>

<h2><a name='sect18' href='libexpect.3.html#toc18'><b>Acknowledgements</b></a></h2>

<p>Thanks to John Ousterhout (UCBerkeley) for supplying the pattern
matcher.</p>

<p>Design and implementation of the <b>expect</b> library was paid
for by the U.S. government and is therefore in the public domain.
However the author and NIST would like credit if this program and
documentation or portions of them are used.</p>

<dl>
<dt>12 December 1991</dt>

<dd><a href='LIBEXPECT.3.html'>LIBEXPECT(3)</a></dd>
</dl>

<hr>
<p><a name='toc'><b>Table of Contents</b></a></p>

<ul>
<li><a name='toc0' href='libexpect.3.html#sect0'>Name</a></li>

<li><a name='toc1' href='libexpect.3.html#sect1'>Description</a></li>

<li><a name='toc2' href='libexpect.3.html#sect2'>Synopsis</a></li>

<li><a name='toc3' href='libexpect.3.html#sect3'>Synopsis</a></li>

<li><a name='toc4' href='libexpect.3.html#sect4'>Description</a></li>

<li><a name='toc5' href='libexpect.3.html#sect5'>If You Want to Allocate Your Own
Pty</a></li>

<li><a name='toc6' href='libexpect.3.html#sect6'>Expect Processing</a></li>

<li><a name='toc7' href='libexpect.3.html#sect7'>Running in the Background</a></li>

<li><a name='toc8' href='libexpect.3.html#sect8'>Multiplexing</a></li>

<li><a name='toc9' href='libexpect.3.html#sect9'>Slave Control</a></li>

<li><a name='toc10' href='libexpect.3.html#sect10'>Errors</a></li>

<li><a name='toc11' href='libexpect.3.html#sect11'>Signals</a></li>

<li><a name='toc12' href='libexpect.3.html#sect12'>Logging</a></li>

<li><a name='toc13' href='libexpect.3.html#sect13'>Debugging</a></li>

<li><a name='toc14' href='libexpect.3.html#sect14'>Caveats</a></li>

<li><a name='toc15' href='libexpect.3.html#sect15'>Bugs</a></li>

<li><a name='toc16' href='libexpect.3.html#sect16'>See Also</a></li>

<li><a name='toc17' href='libexpect.3.html#sect17'>Author</a></li>

<li><a name='toc18' href='libexpect.3.html#sect18'>Acknowledgements</a></li>
</ul>
</body>
</html>


			<aside class="copyright" role="note">
				
				Documentation built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>

			<footer class="footer">
				<div class="as_footer">
  
  <div class="prod_links">
    <strong>
      <a href="http://platform.activestate.com/" target="_blank">ActiveState Platform</a>&nbsp;&nbsp;
      <a href="http://www.activestate.com/downloads" target="_blank">Downloads</a>&nbsp;&nbsp;
      <a href="http://community.activestate.com/" target="_blank">Community</a>&nbsp;&nbsp;
      <a href="http://github.com/activestate/code" target="_blank">Code Recipes</a>&nbsp;&nbsp;
    </strong>
  </div>
  <div class="as_copyright"> 
    &copy; 2019 ActiveState Software Inc. All rights reserved. <strong><a href="../../trademarks/index.html">Trademarks</a>. <a href="http://www.activestate.com/privacy-policy">Privacy Policy</a>.</strong>
  </div>
</div>

			</footer>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = '';
      var repo_id  = '';
    
    </script>

    <script src="../../javascripts/application.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var headers   = document.getElementsByTagName("h2");
      var scrollspy = document.getElementById('scrollspy');

      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;

            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }


        /* Add permanent link next to the headers */
        var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

        for(var i = 0; i < headers.length; i++) {
            var a = document.createElement("a");
            a.setAttribute("class", "headerlink");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", "Permanent link")
            a.innerHTML = "¶";
            headers[i].appendChild(a);
        }
      }
    </script>

    
      <script>
        (function(i,s,o,g,r,a,m){
          i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||
          []).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;
          m.parentNode.insertBefore(a,m)
        })(window, document,
          'script', '//www.google-analytics.com/analytics.js', 'ga');
         
        ga('create', 'UA-20072-24', 'auto');
        ga('set', 'anonymizeIp', true);
        ga('send', 'pageview');
         
        var buttons = document.querySelectorAll('a');
        Array.prototype.map.call(buttons, function(item) {
          if (item.host != document.location.host) {
            item.addEventListener('click', function() {
              var action = item.getAttribute('data-action') || 'follow';
              ga('send', 'event', 'outbound', action, item.href);
            });
          }
        });
         
        var query = document.querySelector('.query');
        query.addEventListener('blur', function() {
          if (this.value) {
            var path = document.location.pathname;
            ga('send', 'pageview', path + '?q=' + this.value);
          }
        });
      </script>
    

    <script src="../../javascripts/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

